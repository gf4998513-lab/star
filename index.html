<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AXInÂ·ä¹ç†æ•° - 3D Particle System</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Times New Roman', serif; /* è¡¬çº¿ä½“ */
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* é¡¶éƒ¨æ ‡é¢˜ */
        #header {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            font-size: 24px;
            letter-spacing: 4px;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* éŸ³ä¹ä¸Šä¼ æŒ‰é’® */
        #ui-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            cursor: pointer;
            font-family: sans-serif;
            font-size: 14px;
            border-radius: 20px;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        /* éšè—æ–‡ä»¶è¾“å…¥ */
        #file-input {
            display: none;
        }

        /* åŠ è½½æç¤º */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: sans-serif;
            font-size: 12px;
            opacity: 0.5;
            pointer-events: none;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="header">AXInÂ·ä¹ç†æ•°</div>
    
    <div id="loading">Initialize System...</div>

    <div id="canvas-container"></div>

    <div id="ui-controls">
        <button class="btn" onclick="document.getElementById('file-input').click()">ğŸµ Upload Music</button>
        <input type="file" id="file-input" accept="audio/*">
        <button class="btn" id="fullscreen-btn">â›¶ Fullscreen</button>
    </div>

    <!-- Import Map for Three.js modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- å…¨å±€å˜é‡é…ç½® ---
        const config = {
            particleCount: 15000,
            particleSize: 1.5,
            colorBase: 0x00ffff,
            colorVar: 0xff00ff,
            brightness: 1.0,
            bloomStrength: 1.5,
            bloomRadius: 0.4,
            bloomThreshold: 0.1,
            flowSpeed: 0.5,
            autoRotate: true,
            shape: 'Tetrahedron' // åˆå§‹å½¢çŠ¶
        };

        // --- åœºæ™¯åˆå§‹åŒ– ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 80);

        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // --- äº¤äº’æ§åˆ¶ ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = config.autoRotate;
        controls.autoRotateSpeed = 0.5;

        // --- éŸ³é¢‘ç³»ç»Ÿ ---
        const listener = new THREE.AudioListener();
        camera.add(listener);
        const sound = new THREE.Audio(listener);
        const audioLoader = new THREE.AudioLoader();
        const analyser = new THREE.AudioAnalyser(sound, 128); // å¿«é€Ÿå‚…é‡Œå¶å˜æ¢
        let audioData = 0; // å¹³å‡é¢‘ç‡

        // --- ç²’å­ç³»ç»Ÿæ ¸å¿ƒ ---
        // æˆ‘ä»¬ä½¿ç”¨ ShaderMaterial æ¥å®ç°é«˜çº§çš„é¢œè‰²æ¸å˜å’Œæ€§èƒ½
        const particlesGeometry = new THREE.BufferGeometry();
        
        // é¢„åˆ†é…ç¼“å†²åŒº
        const maxParticles = 50000;
        const positions = new Float32Array(maxParticles * 3);
        const targetPositions = new Float32Array(maxParticles * 3); // ç›®æ ‡ä½ç½®
        const colors = new Float32Array(maxParticles * 3);
        const sizes = new Float32Array(maxParticles);
        const randoms = new Float32Array(maxParticles); // ç”¨äºéšæœºé—ªçƒ

        for (let i = 0; i < maxParticles; i++) {
            positions[i * 3] = 0;
            positions[i * 3 + 1] = 0;
            positions[i * 3 + 2] = 0;
            
            targetPositions[i * 3] = (Math.random() - 0.5) * 50;
            targetPositions[i * 3 + 1] = (Math.random() - 0.5) * 50;
            targetPositions[i * 3 + 2] = (Math.random() - 0.5) * 50;

            const color = new THREE.Color();
            color.setHSL(Math.random(), 0.7, 0.5);
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;

            sizes[i] = Math.random();
            randoms[i] = Math.random();
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        particlesGeometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
        
        // é™åˆ¶åˆå§‹ç»˜åˆ¶æ•°é‡
        particlesGeometry.setDrawRange(0, config.particleCount);

        // è‡ªå®šä¹‰ç€è‰²å™¨
        const particlesMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uSize: { value: config.particleSize },
                uAudio: { value: 0.0 }, // éŸ³é¢‘è¾“å…¥
                uColorBase: { value: new THREE.Color(config.colorBase) },
                uColorVar: { value: new THREE.Color(config.colorVar) },
                uBrightness: { value: config.brightness }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uSize;
                uniform float uAudio;
                attribute float size;
                attribute float aRandom;
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    vColor = color;
                    vec3 pos = position;
                    
                    // ç®€å•çš„æ³¢åŠ¨æ•ˆæœï¼ŒåŸºäºéŸ³é¢‘
                    float noise = sin(pos.y * 0.1 + uTime * 2.0) * cos(pos.x * 0.1 + uTime);
                    pos += normal * noise * (uAudio * 0.1); 

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;

                    // è·ç¦»è¡°å‡å’ŒéŸ³é¢‘è·³åŠ¨
                    float audioScale = 1.0 + uAudio * 0.02;
                    gl_PointSize = uSize * size * audioScale * (300.0 / -mvPosition.z);
                    
                    // é—ªçƒé€»è¾‘
                    vAlpha = 0.5 + 0.5 * sin(uTime * 3.0 + aRandom * 10.0);
                }
            `,
            fragmentShader: `
                uniform vec3 uColorBase;
                uniform vec3 uColorVar;
                uniform float uBrightness;
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    // åœ†å½¢ç²’å­
                    float r = distance(gl_PointCoord, vec2(0.5));
                    if (r > 0.5) discard;

                    // è½¯è¾¹ç¼˜
                    float glow = 1.0 - (r * 2.0);
                    glow = pow(glow, 1.5);

                    // æ··åˆé¢œè‰²: åŸºç¡€è‰² + å‡ ä½•è®¡ç®—è‰² + æ¸å˜
                    vec3 finalColor = mix(uColorBase, vColor, 0.5);
                    finalColor = mix(finalColor, uColorVar, sin(gl_FragCoord.x * 0.01) * 0.5 + 0.5);

                    gl_FragColor = vec4(finalColor * uBrightness, glow * vAlpha);
                }
            `,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });

        const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particleSystem);

        // --- åæœŸå¤„ç† (Bloom/Glow) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = config.bloomThreshold;
        bloomPass.strength = config.bloomStrength;
        bloomPass.radius = config.bloomRadius;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- æ•°å­¦å‡ ä½•ç”Ÿæˆå™¨ ---
        const shapes = {
            // åˆå§‹ï¼šä¸‰æ£±é”¥ (Tetrahedron)
            'Tetrahedron': (i, total) => {
                // ç®€å•èµ·è§ï¼Œæˆ‘ä»¬åœ¨çƒé¢ä¸Šé‡‡æ ·4ä¸ªç‚¹æˆ–éšæœºå¡«å……å†…éƒ¨ï¼Œè¿™é‡Œç”¨æ›´æŠ½è±¡çš„å››é¢ä½“ç»“æ„
                // ä¸ºäº†è§†è§‰æ•ˆæœï¼Œæˆ‘ä»¬åšä¸€ä¸ªå¸¦æœ‰å™ªå£°çš„å››é¢ä½“
                const v = i / total;
                const phase = Math.floor(v * 4); // 0, 1, 2, 3
                const spread = 30;
                let x, y, z;
                // 4 vertices of a tetrahedron
                const p0 = [1, 1, 1];
                const p1 = [-1, -1, 1];
                const p2 = [-1, 1, -1];
                const p3 = [1, -1, -1];
                const pts = [p0, p1, p2, p3];
                
                // Lerp between vertices roughly
                const t = Math.random();
                const start = pts[phase];
                const end = pts[(phase + 1) % 4];
                
                x = (start[0] + (end[0] - start[0]) * t) * spread;
                y = (start[1] + (end[1] - start[1]) * t) * spread;
                z = (start[2] + (end[2] - start[2]) * t) * spread;
                
                // Add volume
                x += (Math.random() - 0.5) * 5;
                y += (Math.random() - 0.5) * 5;
                z += (Math.random() - 0.5) * 5;
                return {x, y, z};
            },
            // é˜¿åŸºç±³å¾·èºæ—‹ (Archimedean Spiral - 3D Tube)
            'Archimedean': (i, total) => {
                const t = (i / total) * 100; 
                const angle = t * 0.5;
                const r = 0.5 * angle;
                const x = r * Math.cos(angle);
                const y = r * Math.sin(angle);
                const z = (i / total) * 100 - 50; // Stretch in Z
                return { x, y, z };
            },
            // è´è¶æ›²çº¿ (Butterfly Curve)
            'Butterfly': (i, total) => {
                const t = (i / total) * 12 * Math.PI;
                // Parametric equation
                const scale = 15;
                const ex = Math.exp(Math.cos(t));
                const term2 = 2 * Math.cos(4*t);
                const term3 = Math.pow(Math.sin(t/12), 5);
                const r = ex - term2 + term3;
                
                const x = scale * Math.sin(t) * r;
                const y = scale * Math.cos(t) * r;
                const z = (Math.random() - 0.5) * 10; // Flattened 3D
                return { x, y, z };
            },
            // ä¼¯åŠªåˆ©åŒæ‰­çº¿ (Lemniscate) - æ‰©å±•åˆ°3D
            'Lemniscate': (i, total) => {
                const t = (i / total) * 2 * Math.PI;
                const scale = 40;
                const denom = 1 + Math.sin(t) * Math.sin(t);
                const x = scale * Math.cos(t) / denom;
                const y = scale * Math.sin(t) * Math.cos(t) / denom;
                const z = scale * Math.sin(t) * 0.5; // Twist in Z
                return { x, y, z };
            },
            // ç«ç‘°æ›²çº¿ (Rose Curve)
            'Rose': (i, total) => {
                const k = 4; // petals
                const t = (i / total) * 2 * Math.PI * 2; // loops
                const scale = 30;
                const r = scale * Math.cos(k * t);
                const x = r * Math.cos(t);
                const y = r * Math.sin(t);
                const z = (i / total) * 40 - 20; // Helix structure
                return { x, y, z };
            },
            // æ‚¬é“¾çº¿ (Catenary) - æ—‹è½¬é¢
            'Catenary': (i, total) => {
                const u = (i / total) * 4 * Math.PI; // rotation
                const v = ((i % 100) / 100) * 4 - 2; // height
                const a = 10;
                const r = a * Math.cosh(v/a);
                const x = r * Math.cos(u);
                const z = r * Math.sin(u);
                const y = v * 15;
                return { x, y, z };
            },
            // ç§‘èµ«/åˆ†å½¢æ¨¡æ‹Ÿ (Sphere with Noise)
            'Koch-Like': (i, total) => {
                // True Koch is hard, simulating a noisy fractal sphere
                const phi = Math.acos(-1 + (2 * i) / total);
                const theta = Math.sqrt(total * Math.PI) * phi;
                const r = 35 + Math.sin(phi * 20) * 5 + Math.cos(theta * 10) * 5;
                
                const x = r * Math.cos(theta) * Math.sin(phi);
                const y = r * Math.sin(theta) * Math.sin(phi);
                const z = r * Math.cos(phi);
                return { x, y, z };
            }
        };

        const shapeKeys = Object.keys(shapes);

        // --- æ ¸å¿ƒé€»è¾‘ï¼šå˜æ¢å½¢çŠ¶ ---
        function transformShape(shapeName) {
            config.shape = shapeName;
            const generator = shapes[shapeName];
            const count = config.particleCount;

            for (let i = 0; i < count; i++) {
                const pos = generator(i, count);
                // ç®€å•çš„éšæœºæ•£å¸ƒï¼Œé¿å…è¿‡äºè§„åˆ™
                targetPositions[i * 3] = pos.x;
                targetPositions[i * 3 + 1] = pos.y;
                targetPositions[i * 3 + 2] = pos.z;
                
                // æ ¹æ®å½¢çŠ¶é‡ç½®é¢œè‰²
                const color = new THREE.Color();
                const hueOffset = (i / count) * 0.5;
                color.setHSL((Math.random() * 0.1) + hueOffset, 0.8, 0.6);
                colors[i*3] = color.r;
                colors[i*3+1] = color.g;
                colors[i*3+2] = color.b;
            }
            particlesGeometry.attributes.color.needsUpdate = true;
        }

        // è‡ªåŠ¨å˜æ¢è®¡æ—¶å™¨
        let lastShapeChange = 0;
        let shapeIndex = 0;

        // --- UI & GUI ---
        const gui = new GUI({ title: 'System Controls' });
        
        // è§†è§‰å‚æ•°
        const folderVisual = gui.addFolder('Visuals');
        folderVisual.add(config, 'particleCount', 1000, maxParticles, 100).name('Particles').onChange(v => {
            particlesGeometry.setDrawRange(0, v);
        });
        folderVisual.add(config, 'particleSize', 0.1, 5.0).name('Size');
        folderVisual.add(config, 'brightness', 0.1, 3.0).name('Brightness');
        folderVisual.addColor(config, 'colorBase').name('Base Color');
        folderVisual.addColor(config, 'colorVar').name('Var Color');
        
        // è¾‰å…‰å‚æ•°
        const folderBloom = gui.addFolder('Bloom/Glow');
        folderBloom.add(config, 'bloomStrength', 0.0, 3.0).onChange(v => bloomPass.strength = v);
        folderBloom.add(config, 'bloomRadius', 0.0, 1.0).onChange(v => bloomPass.radius = v);
        folderBloom.add(config, 'bloomThreshold', 0.0, 1.0).onChange(v => bloomPass.threshold = v);

        // å½¢çŠ¶é€‰æ‹©
        gui.add(config, 'shape', shapeKeys).name('Geometry Model').onChange(transformShape);
        
        // è¿åŠ¨å‚æ•°
        gui.add(config, 'flowSpeed', 0.0, 2.0).name('Morph Speed');
        gui.add(config, 'autoRotate').name('Auto Rotate').onChange(v => controls.autoRotate = v);

        // å¤„ç†éŸ³ä¹ä¸Šä¼ 
        const fileInput = document.getElementById('file-input');
        fileInput.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const audioContext = listener.context;
                    // Resume context if suspended (browser policy)
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    
                    audioLoader.load(e.target.result, function(buffer) {
                        if (sound.isPlaying) sound.stop();
                        sound.setBuffer(buffer);
                        sound.setLoop(true);
                        sound.setVolume(0.5);
                        sound.play();
                        document.querySelector('.btn').textContent = "ğŸµ Playing: " + file.name.substring(0, 15) + "...";
                    });
                };
                reader.readAsDataURL(file); // Load as Data URL for simple implementation
            }
        });

        // å…¨å±é€»è¾‘
        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
            }
        });

        // åˆå§‹åŒ–
        document.getElementById('loading').style.opacity = 0;
        transformShape('Tetrahedron');

        // --- åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            const delta = clock.getDelta();

            // 1. è·å–éŸ³é¢‘æ•°æ®
            if (sound.isPlaying) {
                audioData = analyser.getAverageFrequency(); // 0 - 256
            } else {
                // æ¨¡æ‹Ÿä¸€ä¸ªç¼“æ…¢çš„å‘¼å¸èŠ‚å¥
                audioData = Math.sin(time) * 10 + 10;
            }

            // å½’ä¸€åŒ–éŸ³é¢‘æ•°æ® (0.0 - 1.0) ç”¨äº Shader
            const normalizedAudio = audioData / 128.0;

            // 2. è‡ªåŠ¨åˆ‡æ¢å½¢çŠ¶é€»è¾‘ (åŸºäºéŸ³ä¹èŠ‚å¥æˆ–æ—¶é—´)
            // å½“æ£€æµ‹åˆ°å¼ºçƒˆçš„ä½éŸ³(Beat)æˆ–è€…æ¯éš”10ç§’åˆ‡æ¢ä¸€æ¬¡
            if (time - lastShapeChange > 10) { // æ¯10ç§’
                shapeIndex = (shapeIndex + 1) % shapeKeys.length;
                transformShape(shapeKeys[shapeIndex]);
                lastShapeChange = time;
            } else if (sound.isPlaying && normalizedAudio > 0.8 && time - lastShapeChange > 2) {
                // å¼ºèŠ‚å¥åˆ‡æ¢ (å†·å´æ—¶é—´2ç§’)
                shapeIndex = (shapeIndex + 1) % shapeKeys.length;
                transformShape(shapeKeys[shapeIndex]);
                lastShapeChange = time;
            }

            // 3. ç²’å­ä½ç½®æ›´æ–° (Morphing)
            const positionsAttribute = particlesGeometry.attributes.position;
            const currentPositions = positionsAttribute.array;
            
            // ç§»åŠ¨é€Ÿåº¦å—éŸ³é¢‘å½±å“
            const speed = config.flowSpeed * 0.05 * (1 + normalizedAudio * 2.0);

            for (let i = 0; i < config.particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // ç®€å•çš„çº¿æ€§æ’å€¼ (Lerp) æ¥è¿‘ç›®æ ‡ä½ç½®
                currentPositions[ix] += (targetPositions[ix] - currentPositions[ix]) * speed;
                currentPositions[iy] += (targetPositions[iy] - currentPositions[iy]) * speed;
                currentPositions[iz] += (targetPositions[iz] - currentPositions[iz]) * speed;
            }
            positionsAttribute.needsUpdate = true;

            // 4. æ›´æ–° Shader Uniforms
            particlesMaterial.uniforms.uTime.value = time;
            particlesMaterial.uniforms.uSize.value = config.particleSize;
            particlesMaterial.uniforms.uAudio.value = audioData; // ä¼ å…¥åŸå§‹é¢‘ç‡å€¼ç”¨äºå‰§çƒˆæŠ–åŠ¨
            particlesMaterial.uniforms.uBrightness.value = config.brightness;
            particlesMaterial.uniforms.uColorBase.value.setHex(config.colorBase);
            particlesMaterial.uniforms.uColorVar.value.setHex(config.colorVar);

            // 5. é¢œè‰²éšéŸ³ä¹å¾®è°ƒ (Hue Shift)
            const hueShift = time * 0.05 + normalizedAudio * 0.1;
            particlesMaterial.uniforms.uColorBase.value.offsetHSL(hueShift * 0.01, 0, 0);

            // 6. æ¸²æŸ“
            controls.update();
            composer.render();
        }

        // çª—å£è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // é¼ æ ‡ç‚¹å‡»äº¤äº’ï¼šç¬é—´æ•£å¼€ç²’å­
        window.addEventListener('mousedown', () => {
            const count = config.particleCount;
            for(let i=0; i<count; i++) {
                 // å‘å¤–æ¨å¼€ç›®æ ‡ä½ç½®
                 targetPositions[i*3] *= 1.5;
                 targetPositions[i*3+1] *= 1.5;
                 targetPositions[i*3+2] *= 1.5;
            }
        });
        
        window.addEventListener('mouseup', () => {
             // æ¢å¤å½¢çŠ¶é€»è¾‘ä¼šåœ¨ update loop ä¸­è‡ªåŠ¨æ‹‰å›æ¥ï¼Œ
             // æˆ–è€…åœ¨è¿™é‡Œè°ƒç”¨ transformShape(config.shape) å¼ºåˆ¶é‡ç½®ç›®æ ‡
             transformShape(config.shape);
        });

        animate();
    </script>
</body>
</html>
