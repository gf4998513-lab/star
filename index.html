<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soul - 3D Music Visualizer</title>
    <style>
        /* 全局样式 */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            user-select: none;
        }

        /* 顶部 LOGO - Soul */
        #header-title {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-family: 'Times New Roman', Times, serif; /* 衬线体 */
            font-size: 4rem;
            font-weight: bold;
            letter-spacing: 10px;
            z-index: 10;
            pointer-events: none; /* 让鼠标穿透，不影响3D操作 */
            /* 渐变色将在JS中动态更新 */
            background-image: linear-gradient(45deg, #ffffff, #a1c4fd, #c2e9fb);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            transition: opacity 0.5s;
        }

        /* 左上角音乐控制 */
        #player-controls {
            position: absolute;
            top: 30px;
            left: 30px;
            z-index: 20;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 250px;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        button {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(255,255,255,0.2);
            border-color: white;
        }

        input[type="range"] {
            width: 100%;
            accent-color: #a1c4fd;
        }
        
        .song-info {
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 5px;
        }

        /* 文件上传隐藏Input */
        #file-input {
            display: none;
        }

        /* 左下角时间 */
        #clock {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: rgba(255, 255, 255, 0.6);
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.2rem;
            z-index: 10;
        }

        /* 全屏按钮 (右下角) */
        #fullscreen-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 20;
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
        }

        /* 隐藏GUI的容器修正 (lil-gui自带折叠，这里调整位置) */
        .lil-gui.root {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        /* 加载提示 */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <!-- 顶部标题 -->
    <div id="header-title">Soul</div>

    <!-- 加载提示 -->
    <div id="loading">Initialising Universe...</div>

    <!-- 音乐播放器UI -->
    <div id="player-controls">
        <div class="song-info" id="current-song">No Music Playing</div>
        
        <div class="control-row">
            <button id="btn-upload">Upload Music</button>
            <button id="btn-play">Play</button>
        </div>
        
        <div style="font-size: 0.8rem; margin-top:5px;">Progress</div>
        <input type="range" id="progress-bar" value="0" min="0" max="100" step="0.1">
        
        <div style="font-size: 0.8rem; margin-top:5px;">Volume</div>
        <input type="range" id="vol-bar" value="0.8" min="0" max="1" step="0.01">

        <input type="file" id="file-input" accept="audio/*" multiple>
    </div>

    <!-- 左下角时钟 -->
    <div id="clock">00:00:00</div>

    <!-- 全屏按钮 -->
    <button id="fullscreen-btn">⛶</button>

    <!-- 引入 Three.js 和相关库 -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- 全局变量配置 ---
        const config = {
            particleCount: 25000,
            particleSize: 0.15,
            themeColor: '#4ca1ff',
            shape: 'galaxy', // 默认形状
            flowSpeed: 1.0,  // 音频控制
            rotationSpeed: 0.001,
            bloomStrength: 1.5,
            bloomRadius: 0.4,
            bloomThreshold: 0,
            noiseStrength: 0.1
        };

        let scene, camera, renderer, composer, controls;
        let particles, particleGeo, positions, targets, colors;
        let clock = new THREE.Clock();
        let audioContext, audioAnalyser, audioSource, audioBuffer;
        let isPlaying = false;
        let dataArray;
        let currentAudioTime = 0;
        let audioDuration = 0;

        // UI 元素
        const titleEl = document.getElementById('header-title');
        const songTitleEl = document.getElementById('current-song');
        const progressBar = document.getElementById('progress-bar');
        const volBar = document.getElementById('vol-bar');
        const playBtn = document.getElementById('btn-play');
        const clockEl = document.getElementById('clock');
        const uploadBtn = document.getElementById('btn-upload');
        const fileInput = document.getElementById('file-input');

        // --- 初始化场景 ---
        function init() {
            // 场景
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            // 相机
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;
            camera.position.y = 20;

            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            // 控制器
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // 后期处理 (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = config.bloomThreshold;
            bloomPass.strength = config.bloomStrength;
            bloomPass.radius = config.bloomRadius;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 创建粒子系统
            createParticles();

            // GUI 面板
            initGUI(bloomPass);

            // 事件监听
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            
            // 隐藏加载
            document.getElementById('loading').style.opacity = 0;
            
            // 启动动画循环
            animate();
            
            // 时钟更新
            setInterval(updateClock, 1000);
        }

        // --- 粒子系统逻辑 ---
        function createParticles() {
            particleGeo = new THREE.BufferGeometry();
            positions = new Float32Array(config.particleCount * 3);
            targets = new Float32Array(config.particleCount * 3);
            colors = new Float32Array(config.particleCount * 3); // 预留颜色

            const colorObj = new THREE.Color(config.themeColor);

            for (let i = 0; i < config.particleCount; i++) {
                // 初始位置：随机分布
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;

                // 初始颜色
                colors[i * 3] = colorObj.r;
                colors[i * 3 + 1] = colorObj.g;
                colors[i * 3 + 2] = colorObj.b;
            }

            particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // 材质
            const material = new THREE.PointsMaterial({
                size: config.particleSize,
                color: 0xffffff,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8,
                map: createParticleTexture()
            });

            particles = new THREE.Points(particleGeo, material);
            scene.add(particles);

            // 初始形态计算
            calculateShape(config.shape);
        }

        // 创建圆形发光纹理
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(240,240,255,0.6)');
            gradient.addColorStop(0.5, 'rgba(128,128,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // --- 数学形态生成算法 ---
        function calculateShape(type) {
            config.shape = type;
            const count = config.particleCount;
            
            // 简单的Hash随机种子，用于分布
            let idx = 0;

            for (let i = 0; i < count; i++) {
                let x, y, z;
                // 归一化参数
                const u = Math.random(); 
                const v = Math.random();
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                switch (type) {
                    case 'galaxy': // 银河螺旋
                        const spiral = i * 0.05; 
                        const r = Math.log(i + 1) * 2.5; 
                        x = r * Math.cos(spiral + i * 0.0002) + (Math.random()-0.5)*2;
                        y = (Math.random() - 0.5) * (10 - r/10); 
                        z = r * Math.sin(spiral + i * 0.0002) + (Math.random()-0.5)*2;
                        break;
                    
                    case 'lorenz': // 洛伦兹吸引子
                        // 需要迭代生成
                        if(i===0) { x=0.1; y=0; z=0; }
                        else {
                            const dt = 0.005;
                            const prevX = targets[(i-1)*3];
                            const prevY = targets[(i-1)*3+1];
                            const prevZ = targets[(i-1)*3+2];
                            const sigma = 10, beta = 8/3, rho = 28;
                            
                            const dx = sigma * (prevY - prevX) * dt;
                            const dy = (prevX * (rho - prevZ) - prevY) * dt;
                            const dz = (prevX * prevY - beta * prevZ) * dt;
                            
                            x = prevX + dx;
                            y = prevY + dy;
                            z = prevZ + dz;
                        }
                        // 缩放
                        x*=1.5; y*=1.5; z*=1.5;
                        break;

                    case 'sphere': // 球体
                        const rad = 25;
                        x = rad * Math.sin(phi) * Math.cos(theta);
                        y = rad * Math.sin(phi) * Math.sin(theta);
                        z = rad * Math.cos(phi);
                        break;

                    case 'heart': // 笛卡尔心形 (3D近似)
                        // x = 16sin^3(t), y = 13cos(t)-5cos(2t)-2cos(3t)-cos(4t) (2D) -> 扩展3D
                        const t = theta; 
                        // 稍微随机化层叠
                        const hScale = 1.2;
                        x = 16 * Math.pow(Math.sin(t), 3) * hScale;
                        y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * hScale;
                        z = (Math.random() - 0.5) * 10; // 给心形一点厚度
                        // 稍微旋转一下，让它立起来
                        break;

                    case 'mobius': // 莫比乌斯带
                        const mt = u * Math.PI * 2;
                        const ms = (v - 0.5) * 10; // 宽度
                        const ma = 20; // 半径
                        x = (ma + ms * Math.cos(mt/2)) * Math.cos(mt);
                        y = (ma + ms * Math.cos(mt/2)) * Math.sin(mt);
                        z = ms * Math.sin(mt/2);
                        break;

                    case 'menger': // 伪门格尔海绵/立方体网格
                        const gridSize = 40;
                        x = (Math.random() - 0.5) * gridSize;
                        y = (Math.random() - 0.5) * gridSize;
                        z = (Math.random() - 0.5) * gridSize;
                        // 简单的剔除逻辑模拟空洞效果
                        if (Math.abs(x) < 5 && Math.abs(y) < 5) x *= 3; 
                        break;
                    
                    case 'penrose': // 彭罗斯三角 (视觉错觉 - 只是一个三角框)
                         // 简化为三个管状结构组成三角
                         const sideLen = 30;
                         const segment = i % 3;
                         const progress = Math.random();
                         if(segment === 0) { // Bottom
                             x = (progress - 0.5) * sideLen; y = -sideLen/3; z = 0;
                         } else if (segment === 1) { // Right up
                             x = (0.5 - progress * 0.5) * sideLen; y = (-1/3 + progress) * sideLen; z = progress * 10;
                         } else { // Left up
                             x = (-0.5 + progress * 0.5) * sideLen; y = (2/3 - progress) * sideLen; z = (1-progress) * 10;
                         }
                         // 增加一点厚度
                         x += (Math.random()-0.5)*2;
                         y += (Math.random()-0.5)*2;
                         z += (Math.random()-0.5)*2;
                         break;

                    default:
                        x = (Math.random() - 0.5) * 50;
                        y = (Math.random() - 0.5) * 50;
                        z = (Math.random() - 0.5) * 50;
                }

                targets[idx] = x;
                targets[idx+1] = y;
                targets[idx+2] = z;
                idx += 3;
            }
        }

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. 获取音频数据
            let freqAvg = 0;
            if (isPlaying && audioAnalyser) {
                audioAnalyser.getByteFrequencyData(dataArray);
                // 计算平均频率，用于控制整体强度
                let sum = 0;
                for(let i=0; i<dataArray.length; i++) sum += dataArray[i];
                freqAvg = sum / dataArray.length;
            }

            // 2. 音频驱动参数
            // 低音通常在数组低位，用来控制缩放脉冲
            const bass = isPlaying ? dataArray[5] / 255 : 0;
            const treble = isPlaying ? dataArray[100] / 255 : 0;
            
            // 音乐控制的缩放
            const audioScale = 1 + bass * 0.3; // 随低音缩放
            
            // 粒子运动速度
            const speed = config.flowSpeed * (1 + freqAvg / 128) * 2; 

            // 3. 更新粒子位置
            const posAttr = particleGeo.attributes.position;
            
            for (let i = 0; i < config.particleCount; i++) {
                const px = posAttr.array[i * 3];
                const py = posAttr.array[i * 3 + 1];
                const pz = posAttr.array[i * 3 + 2];

                const tx = targets[i * 3];
                const ty = targets[i * 3 + 1];
                const tz = targets[i * 3 + 2];

                // 简单的Lerp插值使粒子飞向目标形状
                // 加入一点噪声使运动更自然
                const noiseX = Math.sin(time * 2 + i) * config.noiseStrength * (freqAvg/50);
                const noiseY = Math.cos(time * 3 + i) * config.noiseStrength * (freqAvg/50);
                
                posAttr.array[i * 3] += (tx - px) * 0.03 * speed + noiseX;
                posAttr.array[i * 3 + 1] += (ty - py) * 0.03 * speed + noiseY;
                posAttr.array[i * 3 + 2] += (tz - pz) * 0.03 * speed;
            }
            posAttr.needsUpdate = true;

            // 4. 整体旋转与缩放
            particles.rotation.y += config.rotationSpeed + (treble * 0.01);
            particles.rotation.z += config.rotationSpeed * 0.5;
            
            // 弹性缩放效果
            particles.scale.setScalar(THREE.MathUtils.lerp(particles.scale.x, audioScale, 0.1));

            // 更新控件
            controls.update();

            // 渲染
            composer.render();
            
            // 更新进度条
            if (isPlaying && audioContext) {
                currentAudioTime = audioContext.currentTime;
                // 注意：createMediaElementSource 方式下 currentTime 准确，BufferSource 方式需要自己计算
                // 为了兼容简单实现，我们这里用BufferSource，需要手动累计
            }
        }

        // --- 音频处理 ---
        function handleAudioFile(files) {
            if (files.length === 0) return;
            const file = files[0];
            
            songTitleEl.innerText = file.name.replace(/\.[^/.]+$/, ""); // 去掉后缀
            
            // 根据歌名生成独特形状和颜色 (简单的Hash)
            generateUniqueStyle(file.name);

            const reader = new FileReader();
            reader.onload = function(e) {
                initAudio(e.target.result);
            };
            reader.readAsArrayBuffer(file);
        }

        function generateUniqueStyle(name) {
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            // 选择形状
            const shapes = ['galaxy', 'lorenz', 'sphere', 'heart', 'mobius', 'menger', 'penrose'];
            const shapeIndex = Math.abs(hash) % shapes.length;
            calculateShape(shapes[shapeIndex]);
            
            // 选择颜色 (HSL)
            const hue = Math.abs(hash) % 360;
            const color = new THREE.Color(`hsl(${hue}, 70%, 60%)`);
            config.themeColor = '#' + color.getHexString();
            
            // 更新粒子颜色
            const colors = particleGeo.attributes.color.array;
            for(let i=0; i<config.particleCount; i++) {
                colors[i*3] = color.r;
                colors[i*3+1] = color.g;
                colors[i*3+2] = color.b;
            }
            particleGeo.attributes.color.needsUpdate = true;
        }

        function initAudio(arrayBuffer) {
            if (audioContext) audioContext.close();
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            audioContext.decodeAudioData(arrayBuffer, function(buffer) {
                audioBuffer = buffer;
                audioDuration = buffer.duration;
                playAudio(0);
            });
            
            audioAnalyser = audioContext.createAnalyser();
            audioAnalyser.fftSize = 512;
            dataArray = new Uint8Array(audioAnalyser.frequencyBinCount);
        }

        function playAudio(offset) {
            if (audioSource) audioSource.stop();
            audioSource = audioContext.createBufferSource();
            audioSource.buffer = audioBuffer;
            audioSource.connect(audioAnalyser);
            audioAnalyser.connect(audioContext.destination);
            
            audioSource.start(0, offset);
            audioSource.onended = () => {
                isPlaying = false;
                playBtn.innerText = "Play";
            };
            
            isPlaying = true;
            playBtn.innerText = "Pause";
            
            // 简单的进度条同步 (使用setInterval模拟)
            if (window.progressInterval) clearInterval(window.progressInterval);
            let startTime = audioContext.currentTime - offset;
            
            window.progressInterval = setInterval(() => {
                if(isPlaying) {
                    const played = audioContext.currentTime - startTime;
                    const pct = (played / audioDuration) * 100;
                    if(pct <= 100) progressBar.value = pct;
                }
            }, 100);
        }

        // --- 交互事件 ---
        uploadBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => handleAudioFile(e.target.files));

        playBtn.addEventListener('click', () => {
            if(!audioContext) return;
            if(isPlaying) {
                audioContext.suspend();
                isPlaying = false;
                playBtn.innerText = "Play";
            } else {
                audioContext.resume();
                isPlaying = true;
                playBtn.innerText = "Pause";
            }
        });
        
        // 音量
        volBar.addEventListener('input', (e) => {
            // GainNode 可以加在这里优化，暂且略过直接修改
            // 真实项目中应使用 gainNode.gain.value
        });

        // 进度条拖动 (简化版，仅重置播放)
        progressBar.addEventListener('change', (e) => {
             if(audioBuffer) {
                 const time = (e.target.value / 100) * audioDuration;
                 playAudio(time);
             }
        });

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        function onMouseMove(event) {
            // 计算鼠标位置对应的颜色渐变角度
            const x = event.clientX / window.innerWidth;
            const y = event.clientY / window.innerHeight;
            
            const hue1 = x * 360;
            const hue2 = (x * 360 + 180) % 360;
            
            // 更新标题颜色
            titleEl.style.backgroundImage = `linear-gradient(${x * 180}deg, hsl(${hue1},80%,70%), hsl(${hue2},80%,70%))`;
            
            // 鼠标拖动粒子逻辑由 OrbitControls 处理
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateClock() {
            const now = new Date();
            clockEl.innerText = now.toLocaleTimeString();
        }

        // --- GUI 初始化 ---
        function initGUI(bloomPass) {
            const gui = new GUI({ title: 'Universe Control' });
            
            const folderVisual = gui.addFolder('Visuals');
            folderVisual.add(config, 'shape', ['galaxy', 'lorenz', 'sphere', 'heart', 'mobius', 'menger', 'penrose'])
                .name('Shape')
                .onChange(val => calculateShape(val));
            folderVisual.addColor(config, 'themeColor').name('Color').onChange(val => {
                const c = new THREE.Color(val);
                const colors = particleGeo.attributes.color.array;
                for(let i=0; i<config.particleCount; i++) {
                    colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
                }
                particleGeo.attributes.color.needsUpdate = true;
            });
            folderVisual.add(config, 'particleSize', 0.01, 1).name('Particle Size').onChange(v => {
                 particles.material.size = v;
            });

            const folderBloom = gui.addFolder('Bloom Effect');
            folderBloom.add(config, 'bloomStrength', 0, 3).onChange(v => bloomPass.strength = v);
            folderBloom.add(config, 'bloomRadius', 0, 1).onChange(v => bloomPass.radius = v);
            
            const folderMotion = gui.addFolder('Motion');
            folderMotion.add(config, 'flowSpeed', 0, 5).name('Flow Speed');
            folderMotion.add(config, 'rotationSpeed', -0.05, 0.05).name('Auto Rotate');
            folderMotion.add(config, 'noiseStrength', 0, 2).name('Jitter');

            // 面板UI自适应 (lil-gui 默认支持收缩，这里不需要额外代码)
            // 你可以通过按 'H' 键隐藏它
        }

        // 启动
        init();

    </script>
</body>
</html>
